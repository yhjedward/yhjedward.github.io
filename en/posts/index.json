[{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; /** * 状态定义：设 dp 为大小 m×n 矩阵，其中 dp[i][j] 的值代表直到走到 (i,j) 的最小路径和. * 转移方程: 当前单元格 (i,j) 只能从左方单元格 (i−1,j) 或上方单元格 (i,j−1) 走到，故只需要考虑矩阵左边界和上边界. * 初始状态: dp 初始化.数组大小与原始数组相同. dp[0][0] = grid[0][0]. * 返回值: 返回 dp 右下角值即最小路径和. */ class Solution { public: int minPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { if (grid.size() == 0 || grid[0].size() == 0) { return 0; } int rows = grid.size(), columns = grid[0].size(); /** * 1. 创建二维数组, 与原始数组大小相等. * 2. 创建 rows 行, 每行大小为 columns 的一维数组. */ auto dp = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(rows, vector \u0026lt;int\u0026gt; (columns)); // 初始化 dp[0][0] = grid[0][0]; // 遍历第一列 for (int i = 1; i \u0026lt; rows; i++) { dp[i][0] = dp[i-1][0] + grid[i][0]; } // 遍历第一行 for (int j = 1; j \u0026lt; columns; j++) { dp[0][j] = dp[0][j-1] + grid[0][j]; } // 遍历中间元素.其对应的路径最小和即 左边和上边取最小值加上当前元素. for (int i = 1; i \u0026lt; rows; i++) { for (int j = 1; j \u0026lt; columns; j++) { dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]; } } // 返回最后一个元素 return dp[rows-1][columns-1]; } }; int main() { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; grid = { {1, 3, 1}, {1, 5, 1}, {4, 2, 1} }; Solution solution; int result = solution.minPathSum(grid); cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 最小路径和https://leetcode.cn/problems/minimum-path-sum/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":2,"section":"posts","tags":["动态规划"],"title":"最小路径和","uri":"https://yhjedward.github.io/en/posts/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {} }; class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; que; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; // 将树节点添加到队列 if (root != nullptr) que.push(root); while (!que.empty()) { vector\u0026lt;int\u0026gt; tmp; for (int i = que.size(); i \u0026gt; 0; --i) { root = que.front(); // 出队,方便后边添加左右节点到队列 que.pop(); tmp.push_back(root-\u0026gt;val); if (root-\u0026gt;left != nullptr) que.push(root-\u0026gt;left); if (root-\u0026gt;right != nullptr) que.push(root-\u0026gt;right); } res.push_back(tmp); } return res; } }; int main() { TreeNode* root = new TreeNode(3); TreeNode* TreeNode1 = new TreeNode(9); TreeNode* TreeNode2 = new TreeNode(20); TreeNode* TreeNode3 = new TreeNode(15); TreeNode* TreeNode4 = new TreeNode(7); root-\u0026gt;left = TreeNode1; root-\u0026gt;right = TreeNode2; TreeNode1-\u0026gt;left = nullptr; TreeNode1-\u0026gt;right = nullptr; TreeNode2-\u0026gt;left = TreeNode3; TreeNode2-\u0026gt;right = TreeNode4; TreeNode3-\u0026gt;left = nullptr; TreeNode3-\u0026gt;right = nullptr; TreeNode4-\u0026gt;left = nullptr; TreeNode4-\u0026gt;right = nullptr; Solution solution; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result = solution.levelOrder(root); for (int i = 0; i \u0026lt; result.size(); ++i) { cout \u0026lt;\u0026lt; \u0026#34;[\u0026#34;; for (int j = 0; j \u0026lt; result[i].size(); ++j) { cout \u0026lt;\u0026lt;\u0026#34;[\u0026#34; \u0026lt;\u0026lt;result[i][j] \u0026lt;\u0026lt; \u0026#34;]\u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; } } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 二叉树的层序遍历https://leetcode.cn/problems/binary-tree-level-order-traversal/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":3,"section":"posts","tags":["树","广度优先搜索(BFS)"],"title":"二叉树的层序遍历","uri":"https://yhjedward.github.io/en/posts/leetcode/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: int jump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 数组大小为 1 时, 当前位置即终点. if (nums.size() == 1) return 0; /** * curDistance: 当前覆盖最远距离下标 * nextDistance: 下一步覆盖最远距离下标 * ans: 记录走的最大步数. */ int nextDistance = 0, current = 0, ans = 0; for (int i = 0; i \u0026lt; nums.size(); i++) { // 每个索引能够到达的最大索引(取最大值). nextDistance = max (nums[i] + i, nextDistance); // 当前索引到达当前能够覆盖到的索引位置 if (i == current) { // 起跳的次数 ans++; // 当前能够覆盖到的索引位置 current = nextDistance; // 覆盖的最大索引 \u0026gt;= 数组最大索引, 停止起跳. if (nextDistance \u0026gt;= nums.size() - 1) break; } } return ans; } }; int main() { vector\u0026lt;int\u0026gt; nums = {2, 3, 1, 1, 4, 2, 1, 1, 1}; Solution solution; int ans = solution.jump(nums); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 跳跃游戏IIhttps://leetcode.cn/problems/jump-game-ii/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":4,"section":"posts","tags":["贪心法"],"title":"跳跃游戏II","uri":"https://yhjedward.github.io/en/posts/leetcode/%E8%B4%AA%E5%BF%83/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8Fii/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;iostream\u0026gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; class Solution { public: ListNode* swapPairs(ListNode* head) { // 设置虚拟头结点 ListNode* dummyHead = new ListNode(0); // 初始时,虚拟头结点 指向 实际链表的头结点 dummyHead-\u0026gt;next = head; // 当前操作的位置 指向 虚拟头结点,方便操作实际链表的头结点以及后面的节点 ListNode* cur = dummyHead; /**开始遍历 * 遍历终止的条件,分两种情况: * 偶数链表: cur-\u0026gt;next = nullptr; * 奇数链表: cur-\u0026gt;next-\u0026gt;next = nullptr; */ while (cur-\u0026gt;next != nullptr \u0026amp;\u0026amp; cur-\u0026gt;next-\u0026gt;next != nullptr) { // 临时节点保存要交换的节点. ListNode* tmp = cur-\u0026gt;next; ListNode* tmp1 = cur-\u0026gt;next-\u0026gt;next-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; cur-\u0026gt;next-\u0026gt;next = tmp; cur-\u0026gt;next-\u0026gt;next-\u0026gt;next = tmp1; cur = cur-\u0026gt;next-\u0026gt;next; } return dummyHead-\u0026gt;next; } }; int main() { Solution solution; ListNode ListNode7 = { 7,nullptr }; ListNode ListNode6 = { 6,\u0026amp;ListNode7 }; ListNode ListNode5 = { 5,\u0026amp;ListNode6 }; ListNode ListNode4 = { 4,\u0026amp;ListNode5 }; ListNode ListNode3 = { 3,\u0026amp;ListNode4 }; ListNode ListNode2 = { 2,\u0026amp;ListNode3 }; ListNode ListNode1 = { 1,\u0026amp;ListNode2 }; ListNode* head = \u0026amp;ListNode1; ListNode* result = solution.swapPairs(head); while (result != nullptr) { cout \u0026lt;\u0026lt; \u0026#34;result:\u0026#34; \u0026lt;\u0026lt; result-\u0026gt;val \u0026lt;\u0026lt; endl; result = result-\u0026gt;next; } } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 两两交换链表中的节点https://leetcode.cn/problems/swap-nodes-in-pairs/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":5,"section":"posts","tags":["递归法","链表"],"title":"两两交换链表中的节点","uri":"https://yhjedward.github.io/en/posts/leetcode/%E9%80%92%E5%BD%92/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: void backtrack(vector\u0026lt;string\u0026gt;\u0026amp; ans, string\u0026amp; cur, int open, int close, int n) { if (cur.size() == n * 2) { ans.push_back(cur); return; } if (open \u0026lt; n) { cur.push_back(\u0026#39;(\u0026#39;); backtrack(ans, cur, open + 1, close, n); cur.pop_back(); } if (close \u0026lt; open) { cur.push_back(\u0026#39;)\u0026#39;); backtrack(ans, cur, open, close + 1, n); cur.pop_back(); } } vector\u0026lt;string\u0026gt; generateParenthesis(int n) { vector\u0026lt;string\u0026gt; result; string current; backtrack(result, current, 0, 0, n); return result; } }; int main() { Solution solution; vector\u0026lt;string\u0026gt; result = solution.generateParenthesis(3); vector\u0026lt;string\u0026gt;::iterator it; for (it = result.begin(); it != result.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt;endl; } } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 括号生成https://leetcode.cn/problems/generate-parentheses/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":6,"section":"posts","tags":["回溯法"],"title":"括号生成","uri":"https://yhjedward.github.io/en/posts/leetcode/%E5%9B%9E%E6%BA%AF%E6%B3%95/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Solution { public: string longestPalindrome(string s) { unsigned int n = s.size(); if (n \u0026lt; 2) { return s; } int maxLen = 1, begin = 0; /** * 状态: dp[i][j] : 子串s[i....j] 是否是回文串. * 状态转移方程: dp[i][j] = (s[i] == s[j]) 并且 dp[i+1][j-1] * 边界条件: */ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(n)); // 单个的字符是回文串 for(int i = 0; i \u0026lt; n; i++) { dp[i][i] = true; } // 枚举子字符串串长度,通过扩大子字符串的长度寻找回文串. for (int L = 2; L \u0026lt;= n; L++) { // 左边界 for (int i = 0; i \u0026lt; n; i++) { // 右边界 (j - i + 1 = L) int j = L + i - 1; // 右边界越界 if (j \u0026gt;= n) { break; } // 子字符串的左右两边不相等 if (s[i] != s[j]) { dp[i][j] = false; } else { // 达到边界条件 if (j - i \u0026lt; 3) { dp[i][j] = true; } else { dp[i][j] = dp[i+1][j-1]; } } // 子串是回文,更新回文字符串长度和起始位置. if (dp[i][j] \u0026amp;\u0026amp; j - i + 1 \u0026gt; maxLen) { maxLen = j - i + 1; begin = i; } } } return s.substr(begin, maxLen); } }; int main() { Solution solution; string s = \u0026#34;bacad\u0026#34;; string result = solution.longestPalindrome(s); cout\u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 最长回文子串https://leetcode.cn/problems/longest-palindromic-substring/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":7,"section":"posts","tags":["动态规划"],"title":"最长回文子串","uri":"https://yhjedward.github.io/en/posts/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":9,"section":"gallery","tags":null,"title":"Photo","uri":"https://yhjedward.github.io/en/gallery/photo/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":14,"section":"","tags":null,"title":"About","uri":"https://yhjedward.github.io/en/about/"}]