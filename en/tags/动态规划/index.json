[{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;iostream\u0026gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; class Solution { public: ListNode* swapPairs(ListNode* head) { // 设置虚拟头结点 ListNode* dummyHead = new ListNode(0); // 初始时,虚拟头结点 指向 实际链表的头结点 dummyHead-\u0026gt;next = head; // 当前操作的位置 指向 虚拟头结点,方便操作实际链表的头结点以及后面的节点 ListNode* cur = dummyHead; /**开始遍历 * 遍历终止的条件,分两种情况: * 偶数链表: cur-\u0026gt;next = nullptr; * 奇数链表: cur-\u0026gt;next-\u0026gt;next = nullptr; */ while (cur-\u0026gt;next != nullptr \u0026amp;\u0026amp; cur-\u0026gt;next-\u0026gt;next != nullptr) { // 临时节点保存要交换的节点. ListNode* tmp = cur-\u0026gt;next; ListNode* tmp1 = cur-\u0026gt;next-\u0026gt;next-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; cur-\u0026gt;next-\u0026gt;next = tmp; cur-\u0026gt;next-\u0026gt;next-\u0026gt;next = tmp1; cur = cur-\u0026gt;next-\u0026gt;next; } return dummyHead-\u0026gt;next; } }; int main() { Solution solution; ListNode ListNode7 = { 7,nullptr }; ListNode ListNode6 = { 6,\u0026amp;ListNode7 }; ListNode ListNode5 = { 5,\u0026amp;ListNode6 }; ListNode ListNode4 = { 4,\u0026amp;ListNode5 }; ListNode ListNode3 = { 3,\u0026amp;ListNode4 }; ListNode ListNode2 = { 2,\u0026amp;ListNode3 }; ListNode ListNode1 = { 1,\u0026amp;ListNode2 }; ListNode* head = \u0026amp;ListNode1; ListNode* result = solution.swapPairs(head); while (result != nullptr) { cout \u0026lt;\u0026lt; \u0026#34;result:\u0026#34; \u0026lt;\u0026lt; result-\u0026gt;val \u0026lt;\u0026lt; endl; result = result-\u0026gt;next; } } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 两两交换链表中的节点https://leetcode.cn/problems/swap-nodes-in-pairs/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":2,"section":"posts","tags":["递归法","链表"],"title":"两两交换链表中的节点","uri":"https://yhjedward.github.io/en/posts/leetcode/%E9%80%92%E5%BD%92/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: void backtrack(vector\u0026lt;string\u0026gt;\u0026amp; ans, string\u0026amp; cur, int open, int close, int n) { if (cur.size() == n * 2) { ans.push_back(cur); return; } if (open \u0026lt; n) { cur.push_back(\u0026#39;(\u0026#39;); backtrack(ans, cur, open + 1, close, n); cur.pop_back(); } if (close \u0026lt; open) { cur.push_back(\u0026#39;)\u0026#39;); backtrack(ans, cur, open, close + 1, n); cur.pop_back(); } } vector\u0026lt;string\u0026gt; generateParenthesis(int n) { vector\u0026lt;string\u0026gt; result; string current; backtrack(result, current, 0, 0, n); return result; } }; int main() { Solution solution; vector\u0026lt;string\u0026gt; result = solution.generateParenthesis(3); vector\u0026lt;string\u0026gt;::iterator it; for (it = result.begin(); it != result.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt;endl; } } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 括号生成https://leetcode.cn/problems/generate-parentheses/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":3,"section":"posts","tags":["回溯法"],"title":"括号生成","uri":"https://yhjedward.github.io/en/posts/leetcode/%E5%9B%9E%E6%BA%AF%E6%B3%95/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Solution { public: string longestPalindrome(string s) { unsigned int n = s.size(); if (n \u0026lt; 2) { return s; } int maxLen = 1, begin = 0; /** * 状态: dp[i][j] : 子串s[i....j] 是否是回文串. * 状态转移方程: dp[i][j] = (s[i] == s[j]) 并且 dp[i+1][j-1] * 边界条件: */ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(n)); // 单个的字符是回文串 for(int i = 0; i \u0026lt; n; i++) { dp[i][i] = true; } // 枚举子字符串串长度,通过扩大子字符串的长度寻找回文串. for (int L = 2; L \u0026lt;= n; L++) { // 左边界 for (int i = 0; i \u0026lt; n; i++) { // 右边界 (j - i + 1 = L) int j = L + i - 1; // 右边界越界 if (j \u0026gt;= n) { break; } // 子字符串的左右两边不相等 if (s[i] != s[j]) { dp[i][j] = false; } else { // 达到边界条件 if (j - i \u0026lt; 3) { dp[i][j] = true; } else { dp[i][j] = dp[i+1][j-1]; } } // 子串是回文,更新回文字符串长度和起始位置. if (dp[i][j] \u0026amp;\u0026amp; j - i + 1 \u0026gt; maxLen) { maxLen = j - i + 1; begin = i; } } } return s.substr(begin, maxLen); } }; int main() { Solution solution; string s = \u0026#34;bacad\u0026#34;; string result = solution.longestPalindrome(s); cout\u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 最长回文子串https://leetcode.cn/problems/longest-palindromic-substring/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":4,"section":"posts","tags":["动态规划"],"title":"最长回文子串","uri":"https://yhjedward.github.io/en/posts/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":6,"section":"gallery","tags":null,"title":"Photo","uri":"https://yhjedward.github.io/en/gallery/photo/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":11,"section":"","tags":null,"title":"About","uri":"https://yhjedward.github.io/en/about/"}]