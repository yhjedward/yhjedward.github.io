[{"content":"概述 组合是显式的,继承是隐式的. 在类中博涵已有类的功能时,使用组合. ","description":"","id":2,"section":"posts","tags":null,"title":"组合和继承","uri":"https://yhjedward.github.io/en/posts/java/%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF/"},{"content":"接口 概述 接口是指定一组函数成员而不实现它们的引用类型,只能使用类和结构来实现接口. 接口可以有访问修饰符,接口成员不能有访问修饰符. 接口实例 多个接口的引用 派生成员实现接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 using System; interface IIfc1 { void PrintOut(string s); } interface IIfc2 { void PrintOut(string t); } class MyClass: IIfc1, IIfc2 { public void PrintOut(string s) { Console.WriteLine($\u0026#34;Calling through:{s}\u0026#34;); } } class Program { static void Main() { MyClass mc = new MyClass(); // 调用类对象的实现方法 mc.PrintOut(\u0026#34;object\u0026#34;); // 类对象引用转化为接口类型引用 IIfc1 ifc1= (IIfc1)mc; IIfc2 ifc2= (IIfc2)mc; // 调用接口方法 ifc1.PrintOut(\u0026#34;interface1\u0026#34;); ifc2.PrintOut(\u0026#34;interface2\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 using System; interface IIfc1 { void PrintOut(string s); } interface IIfc2 { void PrintOut(string t); } class MyBaseClass { public void PrintOut(string s) { Console.WriteLine($\u0026#34;Calling through:{s}\u0026#34;); } } // 如果类派生自基类并实现了接口, 基类列表中的基类名称必须放在所有接口之前. // 并且只能有一个基类,列出的其它类型必须为接口类型. class Derived: MyBaseClass, IIfc1, IIfc2 { } class Program { static void Main() { Derived d = new Derived(); d.PrintOut(\u0026#34;Object\u0026#34;); } } ","description":"","id":3,"section":"posts","tags":null,"title":"接口","uri":"https://yhjedward.github.io/en/posts/csharp/%E6%8E%A5%E5%8F%A3/"},{"content":"委托 与 事件 概述 委托是引用类型, 委托有引用和对象, 委托类型必须在被用来创建变量以及类型的对象之前声明. 委托声明与方法声明相似, 只是没有实现块. 委托不需要在类内部声明. 委托可以看成一个包含有序方法列表的对象, 其包含的方法具有相同的签名和返回类型. 委托示例 没有参数和返回值的委托类型 调用带返回值的委托 调用带引用参数的委托 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 using System; /** * 定义一个没有参数和返回值的委托类型 * PrintFunction(): 签名 */ delegate void PrintFunction(); class Test { public void Print1() { Console.WriteLine(\u0026#34;调用实例方法\u0026#34;); } public static void Print2() { Console.WriteLine(\u0026#34;调用静态方法\u0026#34;); } } public class main { public static void Main() { Test t = new Test(); // 创建委托引用并赋值 PrintFunction pf = t.Print1; // 绑定,在使用 += 前要先使用 = 赋值. // 如果取消对方法的绑定,使用 -= 运算符. pf += Test.Print2; pf += t.Print1; if (null != pf) // 调用委托 pf(); else Console.WriteLine(\u0026#34;委托没有方法列表\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 using System; /** * 定义一个带有返回值的委托类型 * PrintFunction(): 签名 */ delegate int PrintFunction(); class Test { int IntValue = 5; public int Add1() { IntValue += 1; return IntValue; } public int Add2() { IntValue += 2; return IntValue; } } public class main { public static void Main() { Test t = new Test(); // 创建委托引用并赋值 PrintFunction pf = t.Add1; // 绑定,在使用 += 前要先使用 = 赋值. // 如果取消对方法的绑定,使用 -= 运算符. pf += t.Add1; pf += t.Add2; pf += t.Add1; Console.WriteLine($\u0026#34;Value: { pf() }\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 using System; /** * 定义一个带有引用参数的委托类型 * PrintFunction(): 签名 */ delegate void PrintFunction(ref int x); class Test { public void Add1(ref int x) { x += 1; } public void Add2(ref int x) { x += 2; } } public class main { public static void Main() { Test t = new Test(); // 创建委托引用并赋值 PrintFunction pf = t.Add1; // 绑定,在使用 += 前要先使用 = 赋值. // 如果取消对方法的绑定,使用 -= 运算符. pf += t.Add1; pf += t.Add2; int x = 5; pf(ref x); Console.WriteLine($\u0026#34;Value: { x }\u0026#34;); } } 链接 C#委托与事件 ","description":"","id":4,"section":"posts","tags":null,"title":"委托","uri":"https://yhjedward.github.io/en/posts/csharp/%E5%A7%94%E6%89%98/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; /** * 状态定义：设 dp 为大小 m×n 矩阵，其中 dp[i][j] 的值代表直到走到 (i,j) 的最小路径和. * 转移方程: 当前单元格 (i,j) 只能从左方单元格 (i−1,j) 或上方单元格 (i,j−1) 走到，故只需要考虑矩阵左边界和上边界. * 初始状态: dp 初始化.数组大小与原始数组相同. dp[0][0] = grid[0][0]. * 返回值: 返回 dp 右下角值即最小路径和. */ class Solution { public: int minPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { if (grid.size() == 0 || grid[0].size() == 0) { return 0; } int rows = grid.size(), columns = grid[0].size(); /** * 1. 创建二维数组, 与原始数组大小相等. * 2. 创建 rows 行, 每行大小为 columns 的一维数组. */ auto dp = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(rows, vector \u0026lt;int\u0026gt; (columns)); // 初始化 dp[0][0] = grid[0][0]; // 遍历第一列 for (int i = 1; i \u0026lt; rows; i++) { dp[i][0] = dp[i-1][0] + grid[i][0]; } // 遍历第一行 for (int j = 1; j \u0026lt; columns; j++) { dp[0][j] = dp[0][j-1] + grid[0][j]; } // 遍历中间元素.其对应的路径最小和即 左边和上边取最小值加上当前元素. for (int i = 1; i \u0026lt; rows; i++) { for (int j = 1; j \u0026lt; columns; j++) { dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]; } } // 返回最后一个元素 return dp[rows-1][columns-1]; } }; int main() { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; grid = { {1, 3, 1}, {1, 5, 1}, {4, 2, 1} }; Solution solution; int result = solution.minPathSum(grid); cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 最小路径和https://leetcode.cn/problems/minimum-path-sum/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":5,"section":"posts","tags":["动态规划"],"title":"最小路径和","uri":"https://yhjedward.github.io/en/posts/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {} }; class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; que; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; // 将树节点添加到队列 if (root != nullptr) que.push(root); while (!que.empty()) { vector\u0026lt;int\u0026gt; tmp; for (int i = que.size(); i \u0026gt; 0; --i) { root = que.front(); // 出队,方便后边添加左右节点到队列 que.pop(); tmp.push_back(root-\u0026gt;val); if (root-\u0026gt;left != nullptr) que.push(root-\u0026gt;left); if (root-\u0026gt;right != nullptr) que.push(root-\u0026gt;right); } res.push_back(tmp); } return res; } }; int main() { TreeNode* root = new TreeNode(3); TreeNode* TreeNode1 = new TreeNode(9); TreeNode* TreeNode2 = new TreeNode(20); TreeNode* TreeNode3 = new TreeNode(15); TreeNode* TreeNode4 = new TreeNode(7); root-\u0026gt;left = TreeNode1; root-\u0026gt;right = TreeNode2; TreeNode1-\u0026gt;left = nullptr; TreeNode1-\u0026gt;right = nullptr; TreeNode2-\u0026gt;left = TreeNode3; TreeNode2-\u0026gt;right = TreeNode4; TreeNode3-\u0026gt;left = nullptr; TreeNode3-\u0026gt;right = nullptr; TreeNode4-\u0026gt;left = nullptr; TreeNode4-\u0026gt;right = nullptr; Solution solution; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result = solution.levelOrder(root); for (int i = 0; i \u0026lt; result.size(); ++i) { cout \u0026lt;\u0026lt; \u0026#34;[\u0026#34;; for (int j = 0; j \u0026lt; result[i].size(); ++j) { cout \u0026lt;\u0026lt;\u0026#34;[\u0026#34; \u0026lt;\u0026lt;result[i][j] \u0026lt;\u0026lt; \u0026#34;]\u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; } } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 二叉树的层序遍历https://leetcode.cn/problems/binary-tree-level-order-traversal/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":6,"section":"posts","tags":["树","广度优先搜索(BFS)"],"title":"二叉树的层序遍历","uri":"https://yhjedward.github.io/en/posts/leetcode/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: int jump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 数组大小为 1 时, 当前位置即终点. if (nums.size() == 1) return 0; /** * curDistance: 当前覆盖最远距离下标 * nextDistance: 下一步覆盖最远距离下标 * ans: 记录走的最大步数. */ int nextDistance = 0, current = 0, ans = 0; for (int i = 0; i \u0026lt; nums.size(); i++) { // 每个索引能够到达的最大索引(取最大值). nextDistance = max (nums[i] + i, nextDistance); // 当前索引到达当前能够覆盖到的索引位置 if (i == current) { // 起跳的次数 ans++; // 当前能够覆盖到的索引位置 current = nextDistance; // 覆盖的最大索引 \u0026gt;= 数组最大索引, 停止起跳. if (nextDistance \u0026gt;= nums.size() - 1) break; } } return ans; } }; int main() { vector\u0026lt;int\u0026gt; nums = {2, 3, 1, 1, 4, 2, 1, 1, 1}; Solution solution; int ans = solution.jump(nums); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 跳跃游戏IIhttps://leetcode.cn/problems/jump-game-ii/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":7,"section":"posts","tags":["贪心法"],"title":"跳跃游戏II","uri":"https://yhjedward.github.io/en/posts/leetcode/%E8%B4%AA%E5%BF%83/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8Fii/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;iostream\u0026gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; class Solution { public: ListNode* swapPairs(ListNode* head) { // 设置虚拟头结点 ListNode* dummyHead = new ListNode(0); // 初始时,虚拟头结点 指向 实际链表的头结点 dummyHead-\u0026gt;next = head; // 当前操作的位置 指向 虚拟头结点,方便操作实际链表的头结点以及后面的节点 ListNode* cur = dummyHead; /**开始遍历 * 遍历终止的条件,分两种情况: * 偶数链表: cur-\u0026gt;next = nullptr; * 奇数链表: cur-\u0026gt;next-\u0026gt;next = nullptr; */ while (cur-\u0026gt;next != nullptr \u0026amp;\u0026amp; cur-\u0026gt;next-\u0026gt;next != nullptr) { // 临时节点保存要交换的节点. ListNode* tmp = cur-\u0026gt;next; ListNode* tmp1 = cur-\u0026gt;next-\u0026gt;next-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; cur-\u0026gt;next-\u0026gt;next = tmp; cur-\u0026gt;next-\u0026gt;next-\u0026gt;next = tmp1; cur = cur-\u0026gt;next-\u0026gt;next; } return dummyHead-\u0026gt;next; } }; int main() { Solution solution; ListNode ListNode7 = { 7,nullptr }; ListNode ListNode6 = { 6,\u0026amp;ListNode7 }; ListNode ListNode5 = { 5,\u0026amp;ListNode6 }; ListNode ListNode4 = { 4,\u0026amp;ListNode5 }; ListNode ListNode3 = { 3,\u0026amp;ListNode4 }; ListNode ListNode2 = { 2,\u0026amp;ListNode3 }; ListNode ListNode1 = { 1,\u0026amp;ListNode2 }; ListNode* head = \u0026amp;ListNode1; ListNode* result = solution.swapPairs(head); while (result != nullptr) { cout \u0026lt;\u0026lt; \u0026#34;result:\u0026#34; \u0026lt;\u0026lt; result-\u0026gt;val \u0026lt;\u0026lt; endl; result = result-\u0026gt;next; } } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 两两交换链表中的节点https://leetcode.cn/problems/swap-nodes-in-pairs/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":8,"section":"posts","tags":["递归法","链表"],"title":"两两交换链表中的节点","uri":"https://yhjedward.github.io/en/posts/leetcode/%E9%80%92%E5%BD%92/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: void backtrack(vector\u0026lt;string\u0026gt;\u0026amp; ans, string\u0026amp; cur, int open, int close, int n) { if (cur.size() == n * 2) { ans.push_back(cur); return; } if (open \u0026lt; n) { cur.push_back(\u0026#39;(\u0026#39;); backtrack(ans, cur, open + 1, close, n); cur.pop_back(); } if (close \u0026lt; open) { cur.push_back(\u0026#39;)\u0026#39;); backtrack(ans, cur, open, close + 1, n); cur.pop_back(); } } vector\u0026lt;string\u0026gt; generateParenthesis(int n) { vector\u0026lt;string\u0026gt; result; string current; backtrack(result, current, 0, 0, n); return result; } }; int main() { Solution solution; vector\u0026lt;string\u0026gt; result = solution.generateParenthesis(3); vector\u0026lt;string\u0026gt;::iterator it; for (it = result.begin(); it != result.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt;endl; } } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 括号生成https://leetcode.cn/problems/generate-parentheses/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":9,"section":"posts","tags":["回溯法"],"title":"括号生成","uri":"https://yhjedward.github.io/en/posts/leetcode/%E5%9B%9E%E6%BA%AF%E6%B3%95/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Solution { public: string longestPalindrome(string s) { unsigned int n = s.size(); if (n \u0026lt; 2) { return s; } int maxLen = 1, begin = 0; /** * 状态: dp[i][j] : 子串s[i....j] 是否是回文串. * 状态转移方程: dp[i][j] = (s[i] == s[j]) 并且 dp[i+1][j-1] * 边界条件: */ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(n)); // 单个的字符是回文串 for(int i = 0; i \u0026lt; n; i++) { dp[i][i] = true; } // 枚举子字符串串长度,通过扩大子字符串的长度寻找回文串. for (int L = 2; L \u0026lt;= n; L++) { // 左边界 for (int i = 0; i \u0026lt; n; i++) { // 右边界 (j - i + 1 = L) int j = L + i - 1; // 右边界越界 if (j \u0026gt;= n) { break; } // 子字符串的左右两边不相等 if (s[i] != s[j]) { dp[i][j] = false; } else { // 达到边界条件 if (j - i \u0026lt; 3) { dp[i][j] = true; } else { dp[i][j] = dp[i+1][j-1]; } } // 子串是回文,更新回文字符串长度和起始位置. if (dp[i][j] \u0026amp;\u0026amp; j - i + 1 \u0026gt; maxLen) { maxLen = j - i + 1; begin = i; } } } return s.substr(begin, maxLen); } }; int main() { Solution solution; string s = \u0026#34;bacad\u0026#34;; string result = solution.longestPalindrome(s); cout\u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 最长回文子串https://leetcode.cn/problems/longest-palindromic-substring/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":10,"section":"posts","tags":["动态规划"],"title":"最长回文子串","uri":"https://yhjedward.github.io/en/posts/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"content":"final 数据 final 方法 final 类 ","description":"","id":11,"section":"posts","tags":null,"title":"Final关键字","uri":"https://yhjedward.github.io/en/posts/java/final%E5%85%B3%E9%94%AE%E5%AD%97/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":13,"section":"gallery","tags":null,"title":"Photo","uri":"https://yhjedward.github.io/en/gallery/photo/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":18,"section":"","tags":null,"title":"About","uri":"https://yhjedward.github.io/en/about/"}]