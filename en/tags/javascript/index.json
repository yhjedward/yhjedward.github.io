[{"content":"懒汉模式 概述 他是一个懒汉,不愿动弹.只有你主动叫他的时候他才会工作,即实例在类加载的时候不被初始化,到了需要使用的时候才进行初始化. 饿汉模式 概述 他是一个饿汉,他总是先把食物准备好,什么时候需要吃了,随时拿来吃.即在初始阶段就主动进行实例化,无论此单例是否使用,但是加载慢,获取对象快. 参考链接 design-patterns java版本设计模式 设计模式之禅 设计模式 ","description":"","id":2,"section":"posts","tags":["单例模式"],"title":"单例模式","uri":"https://yhjedward.github.io/en/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"content":"概述 协变性: 子类到父类的转换(如：string-\u0026gt;object). 逆变性: 父类到子类的转换(如：object-\u0026gt;string). 协变性指定返回类型的兼容性，而逆变性指定参数的兼容性. 委托的协变与逆变 代码示例 协变 逆变 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 基类 class Animal { public int Legs = 4; } // 派生类 class Dog : Animal { } // Factory 委托 delegate T Factory\u0026lt;out T\u0026gt;(); class Program { static Dog MakeDog() { return new Dog(); } static void Main(string[] args) { // 创建派生类型的委托 Factory\u0026lt;Dog\u0026gt; dogMaker = MakeDog; // 派生类型构造的委托转为基类型构造的委托 Factory\u0026lt;Animal\u0026gt; animalMaker = dogMaker; Console.WriteLine(animalMaker().Legs.ToString()); } } 接口的逆变与协变 代码示例 协变 逆变 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 interface IFoo\u0026lt;out T\u0026gt; { T GetName(); } class Foo : IFoo\u0026lt;string\u0026gt; { public string GetName() { return GetType().Name; } } class Program { static void Main(string[] args) { IFoo\u0026lt;string\u0026gt; fooStr = new Foo(); IFoo\u0026lt;object\u0026gt; fooObj = fooStr; // IFoo\u0026lt;object\u0026gt; 需要 object 的返回类型. // new Fool().GetName() 方法返回类型是 string 类型. string 类型转化为 object 类型. object memberName = fooObj.GetName(); Console.WriteLine(memberName); Console.Read(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 interface IFoo\u0026lt;in T\u0026gt; { void Print(T content); } class Foo : IFoo\u0026lt;object\u0026gt; { public void Print(object content) { Console.WriteLine(content); } } class Program { static void Main(string[] args) { IFoo\u0026lt;object\u0026gt; fooObj = new Foo(); IFoo\u0026lt;string\u0026gt; fooStr= fooObj; // new Fool().Print() 方法输入参数是 object 类型. // fooStr.Print() 方法输入参数是 string 类型. 隐式将 string 转化为 object. fooStr.Print(\u0026#34;Hello World\u0026#34;); Console.Read(); } } 代码示例 参考链接 协变与逆变 ","description":"","id":3,"section":"posts","tags":null,"title":"协变与逆变","uri":"https://yhjedward.github.io/en/posts/csharp/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/"},{"content":"概述 箭头函数与常规函数对比 常规函数 箭头函数 带有块语法的箭头函数 1 2 3 4 5 function funcName(params) { return params + 2; } funcName(2); // 4 1 2 3 var funcName = (params) =\u0026gt; params + 2 funcName(2); // 4 1 2 3 // 如果使用块语法,需要指定 return 关键字. var funcName = (params) =\u0026gt; { return params + 2 } funcName(2); 箭头函数不会绑定this,即箭头函数不会改变 this 本来的绑定. 每个函数都会有自身的this，但是this并不是在函数声明完就绑定到某个对象上的，只有在函数调用时，this才会被绑定. 常见的 this 指向 全局作用域中或者普通函数中 this 指向全局对象 window. 立即执行函数 this 指向全局对象 window. 定时器的 this 指向全局对象 window. 事件中的 this 指向事件源对象. 方法中的 this 谁调用就指向谁. 构造函数中的 this 指向对象实例. 常规函数 箭头函数 带有块语法的箭头函数 1 2 3 4 5 function funcName(params) { return params + 2; } funcName(2); // 4 1 2 3 var funcName = (params) =\u0026gt; params + 2 funcName(2); // 4 1 2 3 // 如果使用块语法,需要指定 return 关键字. var funcName = (params) =\u0026gt; { return params + 2 } funcName(2); 参考链接 this讲解1 this讲解2 ","description":"","id":4,"section":"posts","tags":["Javascript"],"title":"Javascript箭头函数","uri":"https://yhjedward.github.io/en/posts/%E5%89%8D%E7%AB%AF/javascript/javascript%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"content":"概述 配置安装 electron nodejs官网下载安装 nodejs.js. 使用 npm 安装 pnpm 1 npm install -g pnpm 创建目标项目文件夹 1 mkdir electron_Project 在当前文件夹下使用 pnpm 快速生成 package.json 默认配置 1 pnpm init 使用 pnpm 安装 electron 1 pnpm add -D electron 配置 main.js 文件 ","description":"","id":5,"section":"posts","tags":["Electron"],"title":"Electron环境搭建","uri":"https://yhjedward.github.io/en/posts/%E5%89%8D%E7%AB%AF/electron/electron%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"content":"概述 泛型(generic)特性可以让多个类型共享一组代码。泛型允许我们声明类型参数化(type-parameterized)的代码,用不同的类型进行实例化.即我们可以用“类型占位符”来写代码, 然后在创建类的实例时指明真实的类型. C#提供了5种泛型：类、结构、接口、委托和方法。类, 结构, 接口, 委托是类型, 而方法是成员. 泛型类 概述 泛型类示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class MyStack\u0026lt;T\u0026gt; { T[] StackArray; int StackPointer = 0; public void Push(T x) { if (!IsStackFull) { StackArray[StackPointer++] = x; } } public T pop() { return (!IsStackEmpty) ? StackArray[--StackPointer] : StackArray[0]; } const int MaxStack = 10; bool IsStackFull { get { return StackPointer \u0026gt;= MaxStack; } } bool IsStackEmpty { get { return StackPointer \u0026lt;= 0; } } public MyStack() { StackArray = new T[MaxStack]; } public void Print() { for (int i = StackPointer - 1; i \u0026gt;= 0; i--) { Console.WriteLine($\u0026#34; Value: {StackArray[i]}\u0026#34;); } } } class Program { static void Main(string[] args) { MyStack\u0026lt;int\u0026gt; StackInt = new MyStack\u0026lt;int\u0026gt;(); StackInt.Push(3); StackInt.Push(5); StackInt.Push(7); StackInt.Push(9); StackInt.Print(); MyStack\u0026lt;string\u0026gt; StackString = new MyStack\u0026lt;string\u0026gt;(); StackString.Push(\u0026#34;This is fun\u0026#34;); StackString.Push(\u0026#34;Hi there!\u0026#34;); StackString.Print(); } } 泛型方法 概述 泛型方法示例 泛型接口 概述 泛型接口示例 ","description":"","id":6,"section":"posts","tags":null,"title":"泛型","uri":"https://yhjedward.github.io/en/posts/csharp/%E6%B3%9B%E5%9E%8B/"},{"content":"概述 继承示例 使用基类的引用 虚方法与覆写方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class myBaseClass { public void Print() { Console.WriteLine(\u0026#34;This is the base class.\u0026#34;); } } class MyDerivedClass : myBaseClass { // 使用与基类成员名称相同的成员来屏蔽基类成员. // new 关键字显示告诉编译器隐藏一个基类成员. new public void Print() { Console.WriteLine(\u0026#34;This is the derived class.\u0026#34;); } } class Program { static void Main() { MyDerivedClass derived = new MyDerivedClass(); myBaseClass myBase = (myBaseClass)derived; derived.Print(); myBase.Print(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class myBaseClass { virtual public void Print() { Console.WriteLine(\u0026#34;This is the base class.\u0026#34;); } } class MyDerivedClass : myBaseClass { // 使用与基类成员名称相同的成员来屏蔽基类成员. // new 关键字显示告诉编译器隐藏一个基类成员. override public void Print() { Console.WriteLine(\u0026#34;This is the derived class.\u0026#34;); } } class Program { static void Main() { MyDerivedClass derived = new MyDerivedClass(); myBaseClass myBase = (myBaseClass)derived; derived.Print(); myBase.Print(); } } ","description":"","id":7,"section":"posts","tags":null,"title":"继承","uri":"https://yhjedward.github.io/en/posts/csharp/%E7%BB%A7%E6%89%BF/"},{"content":"概述 组合是显式的,继承是隐式的. 在类中博涵已有类的功能时,使用组合. ","description":"","id":8,"section":"posts","tags":null,"title":"组合和继承","uri":"https://yhjedward.github.io/en/posts/java/%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF/"},{"content":"概述 接口是指定一组函数成员而不实现它们的引用类型,只能使用类和结构来实现接口. 接口可以有访问修饰符,接口成员不能有访问修饰符. 接口实例 多个接口的引用 派生成员实现接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 using System; interface IIfc1 { void PrintOut(string s); } interface IIfc2 { void PrintOut(string t); } class MyClass: IIfc1, IIfc2 { public void PrintOut(string s) { Console.WriteLine($\u0026#34;Calling through:{s}\u0026#34;); } } class Program { static void Main() { MyClass mc = new MyClass(); // 调用类对象的实现方法 mc.PrintOut(\u0026#34;object\u0026#34;); // 类对象引用转化为接口类型引用 IIfc1 ifc1= (IIfc1)mc; IIfc2 ifc2= (IIfc2)mc; // 调用接口方法 ifc1.PrintOut(\u0026#34;interface1\u0026#34;); ifc2.PrintOut(\u0026#34;interface2\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 using System; interface IIfc1 { void PrintOut(string s); } interface IIfc2 { void PrintOut(string t); } class MyBaseClass { public void PrintOut(string s) { Console.WriteLine($\u0026#34;Calling through:{s}\u0026#34;); } } // 如果类派生自基类并实现了接口, 基类列表中的基类名称必须放在所有接口之前. // 并且只能有一个基类,列出的其它类型必须为接口类型. class Derived: MyBaseClass, IIfc1, IIfc2 { } class Program { static void Main() { Derived d = new Derived(); d.PrintOut(\u0026#34;Object\u0026#34;); } } ","description":"","id":9,"section":"posts","tags":null,"title":"接口","uri":"https://yhjedward.github.io/en/posts/csharp/%E6%8E%A5%E5%8F%A3/"},{"content":"概述 委托是引用类型, 委托有引用和对象, 委托类型必须在被用来创建变量以及类型的对象之前声明. 委托声明与方法声明相似, 只是没有实现块. 委托不需要在类内部声明. 委托可以看成一个包含有序方法列表的对象, 其包含的方法具有相同的签名和返回类型. 委托示例 没有参数和返回值的委托类型 调用带返回值的委托 调用带引用参数的委托 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 using System; /** * 定义一个没有参数和返回值的委托类型 * PrintFunction(): 签名 */ delegate void PrintFunction(); class Test { public void Print1() { Console.WriteLine(\u0026#34;调用实例方法\u0026#34;); } public static void Print2() { Console.WriteLine(\u0026#34;调用静态方法\u0026#34;); } } public class main { public static void Main() { Test t = new Test(); // 创建委托引用并赋值 PrintFunction pf = t.Print1; // 绑定,在使用 += 前要先使用 = 赋值. // 如果取消对方法的绑定,使用 -= 运算符. pf += Test.Print2; pf += t.Print1; if (null != pf) // 调用委托 pf(); else Console.WriteLine(\u0026#34;委托没有方法列表\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 using System; /** * 定义一个带有返回值的委托类型 * PrintFunction(): 签名 */ delegate int PrintFunction(); class Test { int IntValue = 5; public int Add1() { IntValue += 1; return IntValue; } public int Add2() { IntValue += 2; return IntValue; } } public class main { public static void Main() { Test t = new Test(); // 创建委托引用并赋值 PrintFunction pf = t.Add1; // 绑定,在使用 += 前要先使用 = 赋值. // 如果取消对方法的绑定,使用 -= 运算符. pf += t.Add1; pf += t.Add2; pf += t.Add1; Console.WriteLine($\u0026#34;Value: { pf() }\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 using System; /** * 定义一个带有引用参数的委托类型 * PrintFunction(): 签名 */ delegate void PrintFunction(ref int x); class Test { public void Add1(ref int x) { x += 1; } public void Add2(ref int x) { x += 2; } } public class main { public static void Main() { Test t = new Test(); // 创建委托引用并赋值 PrintFunction pf = t.Add1; // 绑定,在使用 += 前要先使用 = 赋值. // 如果取消对方法的绑定,使用 -= 运算符. pf += t.Add1; pf += t.Add2; int x = 5; pf(ref x); Console.WriteLine($\u0026#34;Value: { x }\u0026#34;); } } 链接 C#委托与事件 ","description":"","id":10,"section":"posts","tags":null,"title":"委托与事件","uri":"https://yhjedward.github.io/en/posts/csharp/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; /** * 状态定义：设 dp 为大小 m×n 矩阵，其中 dp[i][j] 的值代表直到走到 (i,j) 的最小路径和. * 转移方程: 当前单元格 (i,j) 只能从左方单元格 (i−1,j) 或上方单元格 (i,j−1) 走到，故只需要考虑矩阵左边界和上边界. * 初始状态: dp 初始化.数组大小与原始数组相同. dp[0][0] = grid[0][0]. * 返回值: 返回 dp 右下角值即最小路径和. */ class Solution { public: int minPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { if (grid.size() == 0 || grid[0].size() == 0) { return 0; } int rows = grid.size(), columns = grid[0].size(); /** * 1. 创建二维数组, 与原始数组大小相等. * 2. 创建 rows 行, 每行大小为 columns 的一维数组. */ auto dp = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(rows, vector \u0026lt;int\u0026gt; (columns)); // 初始化 dp[0][0] = grid[0][0]; // 遍历第一列 for (int i = 1; i \u0026lt; rows; i++) { dp[i][0] = dp[i-1][0] + grid[i][0]; } // 遍历第一行 for (int j = 1; j \u0026lt; columns; j++) { dp[0][j] = dp[0][j-1] + grid[0][j]; } // 遍历中间元素.其对应的路径最小和即 左边和上边取最小值加上当前元素. for (int i = 1; i \u0026lt; rows; i++) { for (int j = 1; j \u0026lt; columns; j++) { dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]; } } // 返回最后一个元素 return dp[rows-1][columns-1]; } }; int main() { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; grid = { {1, 3, 1}, {1, 5, 1}, {4, 2, 1} }; Solution solution; int result = solution.minPathSum(grid); cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 最小路径和https://leetcode.cn/problems/minimum-path-sum/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":11,"section":"posts","tags":["动态规划"],"title":"最小路径和","uri":"https://yhjedward.github.io/en/posts/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {} }; class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; que; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; // 将树节点添加到队列 if (root != nullptr) que.push(root); while (!que.empty()) { vector\u0026lt;int\u0026gt; tmp; for (int i = que.size(); i \u0026gt; 0; --i) { root = que.front(); // 出队,方便后边添加左右节点到队列 que.pop(); tmp.push_back(root-\u0026gt;val); if (root-\u0026gt;left != nullptr) que.push(root-\u0026gt;left); if (root-\u0026gt;right != nullptr) que.push(root-\u0026gt;right); } res.push_back(tmp); } return res; } }; int main() { TreeNode* root = new TreeNode(3); TreeNode* TreeNode1 = new TreeNode(9); TreeNode* TreeNode2 = new TreeNode(20); TreeNode* TreeNode3 = new TreeNode(15); TreeNode* TreeNode4 = new TreeNode(7); root-\u0026gt;left = TreeNode1; root-\u0026gt;right = TreeNode2; TreeNode1-\u0026gt;left = nullptr; TreeNode1-\u0026gt;right = nullptr; TreeNode2-\u0026gt;left = TreeNode3; TreeNode2-\u0026gt;right = TreeNode4; TreeNode3-\u0026gt;left = nullptr; TreeNode3-\u0026gt;right = nullptr; TreeNode4-\u0026gt;left = nullptr; TreeNode4-\u0026gt;right = nullptr; Solution solution; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result = solution.levelOrder(root); for (int i = 0; i \u0026lt; result.size(); ++i) { cout \u0026lt;\u0026lt; \u0026#34;[\u0026#34;; for (int j = 0; j \u0026lt; result[i].size(); ++j) { cout \u0026lt;\u0026lt;\u0026#34;[\u0026#34; \u0026lt;\u0026lt;result[i][j] \u0026lt;\u0026lt; \u0026#34;]\u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; } } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 二叉树的层序遍历https://leetcode.cn/problems/binary-tree-level-order-traversal/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":12,"section":"posts","tags":["树","广度优先搜索(BFS)"],"title":"二叉树的层序遍历","uri":"https://yhjedward.github.io/en/posts/leetcode/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: int jump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 数组大小为 1 时, 当前位置即终点. if (nums.size() == 1) return 0; /** * curDistance: 当前覆盖最远距离下标 * nextDistance: 下一步覆盖最远距离下标 * ans: 记录走的最大步数. */ int nextDistance = 0, current = 0, ans = 0; for (int i = 0; i \u0026lt; nums.size(); i++) { // 每个索引能够到达的最大索引(取最大值). nextDistance = max (nums[i] + i, nextDistance); // 当前索引到达当前能够覆盖到的索引位置 if (i == current) { // 起跳的次数 ans++; // 当前能够覆盖到的索引位置 current = nextDistance; // 覆盖的最大索引 \u0026gt;= 数组最大索引, 停止起跳. if (nextDistance \u0026gt;= nums.size() - 1) break; } } return ans; } }; int main() { vector\u0026lt;int\u0026gt; nums = {2, 3, 1, 1, 4, 2, 1, 1, 1}; Solution solution; int ans = solution.jump(nums); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 跳跃游戏IIhttps://leetcode.cn/problems/jump-game-ii/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":13,"section":"posts","tags":["贪心法"],"title":"跳跃游戏II","uri":"https://yhjedward.github.io/en/posts/leetcode/%E8%B4%AA%E5%BF%83/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8Fii/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;iostream\u0026gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; class Solution { public: ListNode* swapPairs(ListNode* head) { // 设置虚拟头结点 ListNode* dummyHead = new ListNode(0); // 初始时,虚拟头结点 指向 实际链表的头结点 dummyHead-\u0026gt;next = head; // 当前操作的位置 指向 虚拟头结点,方便操作实际链表的头结点以及后面的节点 ListNode* cur = dummyHead; /**开始遍历 * 遍历终止的条件,分两种情况: * 偶数链表: cur-\u0026gt;next = nullptr; * 奇数链表: cur-\u0026gt;next-\u0026gt;next = nullptr; */ while (cur-\u0026gt;next != nullptr \u0026amp;\u0026amp; cur-\u0026gt;next-\u0026gt;next != nullptr) { // 临时节点保存要交换的节点. ListNode* tmp = cur-\u0026gt;next; ListNode* tmp1 = cur-\u0026gt;next-\u0026gt;next-\u0026gt;next; cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; cur-\u0026gt;next-\u0026gt;next = tmp; cur-\u0026gt;next-\u0026gt;next-\u0026gt;next = tmp1; cur = cur-\u0026gt;next-\u0026gt;next; } return dummyHead-\u0026gt;next; } }; int main() { Solution solution; ListNode ListNode7 = { 7,nullptr }; ListNode ListNode6 = { 6,\u0026amp;ListNode7 }; ListNode ListNode5 = { 5,\u0026amp;ListNode6 }; ListNode ListNode4 = { 4,\u0026amp;ListNode5 }; ListNode ListNode3 = { 3,\u0026amp;ListNode4 }; ListNode ListNode2 = { 2,\u0026amp;ListNode3 }; ListNode ListNode1 = { 1,\u0026amp;ListNode2 }; ListNode* head = \u0026amp;ListNode1; ListNode* result = solution.swapPairs(head); while (result != nullptr) { cout \u0026lt;\u0026lt; \u0026#34;result:\u0026#34; \u0026lt;\u0026lt; result-\u0026gt;val \u0026lt;\u0026lt; endl; result = result-\u0026gt;next; } } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 两两交换链表中的节点https://leetcode.cn/problems/swap-nodes-in-pairs/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":14,"section":"posts","tags":["递归法","链表"],"title":"两两交换链表中的节点","uri":"https://yhjedward.github.io/en/posts/leetcode/%E9%80%92%E5%BD%92/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: void backtrack(vector\u0026lt;string\u0026gt;\u0026amp; ans, string\u0026amp; cur, int open, int close, int n) { if (cur.size() == n * 2) { ans.push_back(cur); return; } if (open \u0026lt; n) { cur.push_back(\u0026#39;(\u0026#39;); backtrack(ans, cur, open + 1, close, n); cur.pop_back(); } if (close \u0026lt; open) { cur.push_back(\u0026#39;)\u0026#39;); backtrack(ans, cur, open, close + 1, n); cur.pop_back(); } } vector\u0026lt;string\u0026gt; generateParenthesis(int n) { vector\u0026lt;string\u0026gt; result; string current; backtrack(result, current, 0, 0, n); return result; } }; int main() { Solution solution; vector\u0026lt;string\u0026gt; result = solution.generateParenthesis(3); vector\u0026lt;string\u0026gt;::iterator it; for (it = result.begin(); it != result.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt;endl; } } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 括号生成https://leetcode.cn/problems/generate-parentheses/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":15,"section":"posts","tags":["回溯法"],"title":"括号生成","uri":"https://yhjedward.github.io/en/posts/leetcode/%E5%9B%9E%E6%BA%AF%E6%B3%95/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"content":"题目描述1 代码 c java python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Solution { public: string longestPalindrome(string s) { unsigned int n = s.size(); if (n \u0026lt; 2) { return s; } int maxLen = 1, begin = 0; /** * 状态: dp[i][j] : 子串s[i....j] 是否是回文串. * 状态转移方程: dp[i][j] = (s[i] == s[j]) 并且 dp[i+1][j-1] * 边界条件: */ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(n)); // 单个的字符是回文串 for(int i = 0; i \u0026lt; n; i++) { dp[i][i] = true; } // 枚举子字符串串长度,通过扩大子字符串的长度寻找回文串. for (int L = 2; L \u0026lt;= n; L++) { // 左边界 for (int i = 0; i \u0026lt; n; i++) { // 右边界 (j - i + 1 = L) int j = L + i - 1; // 右边界越界 if (j \u0026gt;= n) { break; } // 子字符串的左右两边不相等 if (s[i] != s[j]) { dp[i][j] = false; } else { // 达到边界条件 if (j - i \u0026lt; 3) { dp[i][j] = true; } else { dp[i][j] = dp[i+1][j-1]; } } // 子串是回文,更新回文字符串长度和起始位置. if (dp[i][j] \u0026amp;\u0026amp; j - i + 1 \u0026gt; maxLen) { maxLen = j - i + 1; begin = i; } } } return s.substr(begin, maxLen); } }; int main() { Solution solution; string s = \u0026#34;bacad\u0026#34;; string result = solution.longestPalindrome(s); cout\u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } 1 2 3 4 func main(){ fmt.Printf(\u0026#34;Hello World~\u0026#34;) return } 1 2 3 def main(): print(\u0026#34;Hello World~\u0026#34;) return 链接 最长回文子串https://leetcode.cn/problems/longest-palindromic-substring/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"","id":16,"section":"posts","tags":["动态规划"],"title":"最长回文子串","uri":"https://yhjedward.github.io/en/posts/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"content":"final 数据 final 方法 final 类 ","description":"","id":17,"section":"posts","tags":null,"title":"Final关键字","uri":"https://yhjedward.github.io/en/posts/java/final%E5%85%B3%E9%94%AE%E5%AD%97/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":19,"section":"gallery","tags":null,"title":"Photo","uri":"https://yhjedward.github.io/en/gallery/photo/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":24,"section":"","tags":null,"title":"About","uri":"https://yhjedward.github.io/en/about/"}]